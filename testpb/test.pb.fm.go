// GENERATED CODE - DO NOT EDIT
// This file was generated by protoc-gen-fastmarshal

package testpb

import (
	"fmt"
	"sync/atomic"
	"github.com/CrowdStrike/csproto"
)

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for TestMessage

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *TestMessage) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// Name (string,optional)
	if l = len(m.Name); l > 0 {
		sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// City (string,optional)
	if l = len(m.City); l > 0 {
		sz += csproto.SizeOfTagKey(2) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *TestMessage) Marshal() ([]byte, error) {
	siz := m.Size()
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *TestMessage) MarshalTo(dest []byte) error {
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// Name (1,string,optional)
	if len(m.Name) > 0 {
		enc.EncodeString(1, m.Name)
	}
	// City (2,string,optional)
	if len(m.City) > 0 {
		enc.EncodeString(2, m.City)
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *TestMessage) Unmarshal(p []byte) error {
	if len(p) == 0 {
		return fmt.Errorf("cannot unmarshal from an empty buffer")
	}
	// clear any existing data
	m.Reset()
	dec := csproto.NewDecoder(p)
	// enable faster, but unsafe, string decoding
	dec.SetMode(csproto.DecoderModeFast)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // Name (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'name' (tag=1), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'name' (tag=1): %w", err)
			} else {
				m.Name = s
			}

		case 2: // City (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'city' (tag=2), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'city' (tag=2): %w", err)
			} else {
				m.City = s
			}

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for TestRequest

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *TestRequest) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// Lower (string,optional)
	if l = len(m.Lower); l > 0 {
		sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// RepeatCount (int32,optional)
	if m.RepeatCount != 0 {
		sz += csproto.SizeOfTagKey(2) + csproto.SizeOfVarint(uint64(m.RepeatCount))
	}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *TestRequest) Marshal() ([]byte, error) {
	siz := m.Size()
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *TestRequest) MarshalTo(dest []byte) error {
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// Lower (1,string,optional)
	if len(m.Lower) > 0 {
		enc.EncodeString(1, m.Lower)
	}
	// RepeatCount (2,int32,optional)
	if m.RepeatCount != 0 {
		enc.EncodeInt32(2, m.RepeatCount)
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *TestRequest) Unmarshal(p []byte) error {
	if len(p) == 0 {
		return fmt.Errorf("cannot unmarshal from an empty buffer")
	}
	// clear any existing data
	m.Reset()
	dec := csproto.NewDecoder(p)
	// enable faster, but unsafe, string decoding
	dec.SetMode(csproto.DecoderModeFast)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // Lower (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'lower' (tag=1), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'lower' (tag=1): %w", err)
			} else {
				m.Lower = s
			}

		case 2: // RepeatCount (int32,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'repeat_count' (tag=2), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt32(); err != nil {
				return fmt.Errorf("unable to decode int32 value for field 'repeat_count' (tag=2): %w", err)
			} else {
				m.RepeatCount = v
			}

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for TestResponse

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *TestResponse) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// Value (string,optional)
	if l = len(m.Value); l > 0 {
		sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *TestResponse) Marshal() ([]byte, error) {
	siz := m.Size()
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *TestResponse) MarshalTo(dest []byte) error {
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// Value (1,string,optional)
	if len(m.Value) > 0 {
		enc.EncodeString(1, m.Value)
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *TestResponse) Unmarshal(p []byte) error {
	if len(p) == 0 {
		return fmt.Errorf("cannot unmarshal from an empty buffer")
	}
	// clear any existing data
	m.Reset()
	dec := csproto.NewDecoder(p)
	// enable faster, but unsafe, string decoding
	dec.SetMode(csproto.DecoderModeFast)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // Value (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'value' (tag=1), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'value' (tag=1): %w", err)
			} else {
				m.Value = s
			}

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for CacheStats

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *CacheStats) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// Items (int64,optional)
	if m.Items != 0 {
		sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(m.Items))
	}
	// Bytes (int64,optional)
	if m.Bytes != 0 {
		sz += csproto.SizeOfTagKey(2) + csproto.SizeOfVarint(uint64(m.Bytes))
	}
	// Gets (int64,optional)
	if m.Gets != 0 {
		sz += csproto.SizeOfTagKey(3) + csproto.SizeOfVarint(uint64(m.Gets))
	}
	// Hits (int64,optional)
	if m.Hits != 0 {
		sz += csproto.SizeOfTagKey(4) + csproto.SizeOfVarint(uint64(m.Hits))
	}
	// Evicts (int64,optional)
	if m.Evicts != 0 {
		sz += csproto.SizeOfTagKey(5) + csproto.SizeOfVarint(uint64(m.Evicts))
	}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *CacheStats) Marshal() ([]byte, error) {
	siz := m.Size()
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *CacheStats) MarshalTo(dest []byte) error {
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// Items (1,int64,optional)
	if m.Items != 0 {
		enc.EncodeInt64(1, m.Items)
	}
	// Bytes (2,int64,optional)
	if m.Bytes != 0 {
		enc.EncodeInt64(2, m.Bytes)
	}
	// Gets (3,int64,optional)
	if m.Gets != 0 {
		enc.EncodeInt64(3, m.Gets)
	}
	// Hits (4,int64,optional)
	if m.Hits != 0 {
		enc.EncodeInt64(4, m.Hits)
	}
	// Evicts (5,int64,optional)
	if m.Evicts != 0 {
		enc.EncodeInt64(5, m.Evicts)
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *CacheStats) Unmarshal(p []byte) error {
	if len(p) == 0 {
		return fmt.Errorf("cannot unmarshal from an empty buffer")
	}
	// clear any existing data
	m.Reset()
	dec := csproto.NewDecoder(p)
	// enable faster, but unsafe, string decoding
	dec.SetMode(csproto.DecoderModeFast)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // Items (int64,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'items' (tag=1), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt64(); err != nil {
				return fmt.Errorf("unable to decode int64 value for field 'items' (tag=1): %w", err)
			} else {
				m.Items = v
			}
		case 2: // Bytes (int64,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'bytes' (tag=2), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt64(); err != nil {
				return fmt.Errorf("unable to decode int64 value for field 'bytes' (tag=2): %w", err)
			} else {
				m.Bytes = v
			}
		case 3: // Gets (int64,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'gets' (tag=3), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt64(); err != nil {
				return fmt.Errorf("unable to decode int64 value for field 'gets' (tag=3): %w", err)
			} else {
				m.Gets = v
			}
		case 4: // Hits (int64,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'hits' (tag=4), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt64(); err != nil {
				return fmt.Errorf("unable to decode int64 value for field 'hits' (tag=4): %w", err)
			} else {
				m.Hits = v
			}
		case 5: // Evicts (int64,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'evicts' (tag=5), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt64(); err != nil {
				return fmt.Errorf("unable to decode int64 value for field 'evicts' (tag=5): %w", err)
			} else {
				m.Evicts = v
			}

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for StatsResponse

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *StatsResponse) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// Gets (int64,optional)
	if m.Gets != 0 {
		sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(m.Gets))
	}
	// CacheHits (int64,optional)
	if m.CacheHits != 0 {
		sz += csproto.SizeOfTagKey(12) + csproto.SizeOfVarint(uint64(m.CacheHits))
	}
	// Fills (int64,optional)
	if m.Fills != 0 {
		sz += csproto.SizeOfTagKey(2) + csproto.SizeOfVarint(uint64(m.Fills))
	}
	// TotalAlloc (uint64,optional)
	if m.TotalAlloc != 0 {
		sz += csproto.SizeOfTagKey(3) + csproto.SizeOfVarint(uint64(m.TotalAlloc))
	}
	// MainCache (message,optional)
	if m.MainCache != nil {
		l = csproto.Size(m.MainCache)
		sz += csproto.SizeOfTagKey(4) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// HotCache (message,optional)
	if m.HotCache != nil {
		l = csproto.Size(m.HotCache)
		sz += csproto.SizeOfTagKey(5) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// ServerIn (int64,optional)
	if m.ServerIn != 0 {
		sz += csproto.SizeOfTagKey(6) + csproto.SizeOfVarint(uint64(m.ServerIn))
	}
	// Loads (int64,optional)
	if m.Loads != 0 {
		sz += csproto.SizeOfTagKey(8) + csproto.SizeOfVarint(uint64(m.Loads))
	}
	// PeerLoads (int64,optional)
	if m.PeerLoads != 0 {
		sz += csproto.SizeOfTagKey(9) + csproto.SizeOfVarint(uint64(m.PeerLoads))
	}
	// PeerErrors (int64,optional)
	if m.PeerErrors != 0 {
		sz += csproto.SizeOfTagKey(10) + csproto.SizeOfVarint(uint64(m.PeerErrors))
	}
	// LocalLoads (int64,optional)
	if m.LocalLoads != 0 {
		sz += csproto.SizeOfTagKey(11) + csproto.SizeOfVarint(uint64(m.LocalLoads))
	}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *StatsResponse) Marshal() ([]byte, error) {
	siz := m.Size()
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *StatsResponse) MarshalTo(dest []byte) error {
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// Gets (1,int64,optional)
	if m.Gets != 0 {
		enc.EncodeInt64(1, m.Gets)
	}
	// CacheHits (12,int64,optional)
	if m.CacheHits != 0 {
		enc.EncodeInt64(12, m.CacheHits)
	}
	// Fills (2,int64,optional)
	if m.Fills != 0 {
		enc.EncodeInt64(2, m.Fills)
	}
	// TotalAlloc (3,uint64,optional)
	if m.TotalAlloc != 0 {
		enc.EncodeUInt64(3, m.TotalAlloc)
	}
	// MainCache (4,message,optional)
	if m.MainCache != nil {
		if err = enc.EncodeNested(4, m.MainCache); err != nil {
			return fmt.Errorf("unable to encode message data for field 'main_cache' (tag=4): %w", err)
		}
	}
	// HotCache (5,message,optional)
	if m.HotCache != nil {
		if err = enc.EncodeNested(5, m.HotCache); err != nil {
			return fmt.Errorf("unable to encode message data for field 'hot_cache' (tag=5): %w", err)
		}
	}
	// ServerIn (6,int64,optional)
	if m.ServerIn != 0 {
		enc.EncodeInt64(6, m.ServerIn)
	}
	// Loads (8,int64,optional)
	if m.Loads != 0 {
		enc.EncodeInt64(8, m.Loads)
	}
	// PeerLoads (9,int64,optional)
	if m.PeerLoads != 0 {
		enc.EncodeInt64(9, m.PeerLoads)
	}
	// PeerErrors (10,int64,optional)
	if m.PeerErrors != 0 {
		enc.EncodeInt64(10, m.PeerErrors)
	}
	// LocalLoads (11,int64,optional)
	if m.LocalLoads != 0 {
		enc.EncodeInt64(11, m.LocalLoads)
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *StatsResponse) Unmarshal(p []byte) error {
	if len(p) == 0 {
		return fmt.Errorf("cannot unmarshal from an empty buffer")
	}
	// clear any existing data
	m.Reset()
	dec := csproto.NewDecoder(p)
	// enable faster, but unsafe, string decoding
	dec.SetMode(csproto.DecoderModeFast)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // Gets (int64,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'gets' (tag=1), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt64(); err != nil {
				return fmt.Errorf("unable to decode int64 value for field 'gets' (tag=1): %w", err)
			} else {
				m.Gets = v
			}
		case 12: // CacheHits (int64,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'cache_hits' (tag=12), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt64(); err != nil {
				return fmt.Errorf("unable to decode int64 value for field 'cache_hits' (tag=12): %w", err)
			} else {
				m.CacheHits = v
			}
		case 2: // Fills (int64,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'fills' (tag=2), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt64(); err != nil {
				return fmt.Errorf("unable to decode int64 value for field 'fills' (tag=2): %w", err)
			} else {
				m.Fills = v
			}
		case 3: // TotalAlloc (uint64,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'total_alloc' (tag=3), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeUInt64(); err != nil {
				return fmt.Errorf("unable to decode uint64 value for field 'total_alloc' (tag=3): %w", err)
			} else {
				m.TotalAlloc = v
			}
		case 4: // MainCache (message,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'main_cache' (tag=4), expected 2 (length-delimited)", wt)
			}
			var mm CacheStats
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'main_cache' (tag=4): %w", err)
			}
			m.MainCache = &mm
		case 5: // HotCache (message,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'hot_cache' (tag=5), expected 2 (length-delimited)", wt)
			}
			var mm CacheStats
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'hot_cache' (tag=5): %w", err)
			}
			m.HotCache = &mm
		case 6: // ServerIn (int64,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'server_in' (tag=6), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt64(); err != nil {
				return fmt.Errorf("unable to decode int64 value for field 'server_in' (tag=6): %w", err)
			} else {
				m.ServerIn = v
			}
		case 8: // Loads (int64,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'loads' (tag=8), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt64(); err != nil {
				return fmt.Errorf("unable to decode int64 value for field 'loads' (tag=8): %w", err)
			} else {
				m.Loads = v
			}
		case 9: // PeerLoads (int64,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'peer_loads' (tag=9), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt64(); err != nil {
				return fmt.Errorf("unable to decode int64 value for field 'peer_loads' (tag=9): %w", err)
			} else {
				m.PeerLoads = v
			}
		case 10: // PeerErrors (int64,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'peer_errors' (tag=10), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt64(); err != nil {
				return fmt.Errorf("unable to decode int64 value for field 'peer_errors' (tag=10): %w", err)
			} else {
				m.PeerErrors = v
			}
		case 11: // LocalLoads (int64,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'local_loads' (tag=11), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt64(); err != nil {
				return fmt.Errorf("unable to decode int64 value for field 'local_loads' (tag=11): %w", err)
			} else {
				m.LocalLoads = v
			}

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for Empty

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *Empty) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *Empty) Marshal() ([]byte, error) {
	siz := m.Size()
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *Empty) MarshalTo(dest []byte) error {
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *Empty) Unmarshal(p []byte) error {
	if len(p) == 0 {
		return fmt.Errorf("cannot unmarshal from an empty buffer")
	}
	// clear any existing data
	m.Reset()
	dec := csproto.NewDecoder(p)
	// enable faster, but unsafe, string decoding
	dec.SetMode(csproto.DecoderModeFast)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}
